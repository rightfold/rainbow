#lang racket
(provide (contract-out (translate (-> any/c output-port? void?))))
(define (translate defs out)
  (for ((def defs))
    (translate-def def out)))

(define (translate-def def out)
  (match def
    ((list 'module m)
      (display "module " out)
      (display (symbol->string m) out)
      (display " where\n"))
    ((list 'require m what)
      (display "import " out)
      (display m out)
      (match what
        ((list 'all) void)
        ((list-rest 'only only)
          (display " (" out)
          (display (string-join (map symbol->string only) ", ") out)
          (display ")" out)))
      (display "\n" out))
    ((list 'sig n t)
      (display n out)
      (display " :: " out)
      (translate-type t out)
      (display "\n" out))
    ((list 'def n v)
      (display n out)
      (display " = " out)
      (translate-value v out)
      (display "\n" out))
  )
)

(define (translate-type type out)
  (match type
    ((list 'forall vs in)
      (when (not (null? vs))
        (display "forall " out)
        (display (string-join (map symbol->string vs) " ") out)
        (display ". " out))
      (translate-type in out))
    ((list-rest f as)
      (for ((t (cons f as)))
        (display "(" out)
        (translate-type t out)
        (display ")" out)))
    ((? symbol? n)
      (display (symbol->string n) out))
  )
)

(define (translate-value value out)
  (match value
    ((list-rest f as)
      (for ((t (cons f as)))
        (display "(" out)
        (translate-value t out)
        (display ")" out)))
    ((? symbol? n)
      (display (symbol->string n) out))
  )
)
